#include "Benaloh.h"
#include "math.h" 
#include "stdlib.h"

module BenalohC{
      provides interface Benaloh;
      uses interface Boot;
}

implementation{


call math.pow( i , j);

uint32_t p = 257;
uint32_t q = 173;
/*uint8_t g;
uint8_t h;
uint8_t c;
uint32_t s;
uint32_t t;*/
uint32_t u = 29;
uint32_t y = 1733;


uint16_t gcd(uint16_t a, uint16_t b)
 {
  if (a==0)
  {
  return b;
  }

  else
  {
   while (!b == 0)
      {
        if (a>b)
        {
          a=(a-b);
         }
        else
        {
         b=(b-a);
        }
      } 
   return a;
   }

  } 


int keys(){

uint32_t k,l,m  ;
 if ( ((p-1)/R_SIZE) == 0 )
  {
    dbg("Boot", " (p-1)/R condition is correct ");
 
        if ( gcd(R_SIZE, ((p-1)/R_SIZE)) ==1 )
         {
           dbg("Boot","GCD condition for p and R is correct");
    
            if( gcd((q-1),R_SIZE) == 1 )
             {
               
              dbg("Boot", "GCD condition for q and r is correct");
               
               uint32_t k,l,m ;

              uint32_t k = ((p-1) * (q-1)/R_SIZE);
               l= pow (y,k);
               m= (l % (p*q)); 

             /*((pow (y, ((p-1) * (q-1)/R_SIZE))) %  (p*q))*/
 
               if (  m == 1 )
                  {
                                     
                   /*uint32_t n;*/
                    return (p*q);
                    dbg("Boot", "PUBLIC KEY -- y and n");

                    dbg("Boot", "PRIVATE KEY --  p and q");
                     
                                           
                  }   
              }     
        }
  }


else{
  dbg("Boot", "check values for p and q"); 
    }

}

command void Benaloh.encrypt(uint32_t *in , uint32_t *y, uint32_t *p, uint32_t *q , uint32_t *out){
 
  
   pow( *y, *in);
   pow(u, R_SIZE);
   uint32_t *out = (((pow( y,in)) * (pow(u,R_SIZE))) % (p*q));
  /*uint32_t out = uint32_t o;*/
}



command void Benaloh.decrypt(uint32_t *in,uint32_t *y, uint32_t *p, uint32_t *q , uint32_t *out){

   pow( *y, *in);
   pow( u, R_SIZE);

    uint32_t *out = ((pow(((pow( y, in)) * ( pow( u, R_SIZE))) , ((p-1)(q-1)/R_SIZE))) % (p*q) ); 
   /*uint32_t *out = uint32_t *ot; */

}

}


